<!DOCTYPE HTML>
<html>
<head>
        <title>教學筆記系統</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
    
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>   
        <script src="https://www.gstatic.com/firebasejs/4.9.1/firebase.js"></script>
        <!-- Firebase js -->
        <script src="https://www.gstatic.com/firebasejs/4.6.2/firebase.js"></script>    
        <!-- Firepad related js -->  
        <script src="/javascripts/codemirror.js"></script>     
        <script src="/javascripts/firepad.js"></script> 
        <script src="/javascripts/firebase-init.js"></script>
        <!-- Firepad css -->
        <link rel="stylesheet" href="/stylesheets/codemirror.css" />
        <link rel="stylesheet" href="/stylesheets/firepad.css" />
        
        
        <!-- This page css -->
        <link rel="stylesheet" href="/stylesheets/notePage.css" />
        <link rel="stylesheet" href="/stylesheets/style.css">

        <script src="/javascripts/keywordOverlay.js"></script>
        <script src="/javascripts/bootbox.min.js"></script>

        <!-- Screen Broadcast -->
        <script src="/socket.io/socket.io.js"></script>
        <script src="/javascripts/RTCMultiConnection.min.js"></script>
        <script src="/javascripts/getScreenId.js"></script>

        <script>
            function init(){ 
                initFirebase();
                var userEmail = "<%= user.emails[0].value %>";
                var userEID = userEmail.split('@')[0];
                var firepadRef = firebase.database().ref('/'+'note-'+userEID).child('<%= title %>');

                var codeMirror = CodeMirror(document.getElementById('firepad-container'), { lineWrapping: true });
                hyperlinkOverlay(codeMirror);
                qaOverlay(codeMirror);
                askingOverlay(codeMirror);
                var firepad = Firepad.fromCodeMirror(firepadRef, codeMirror,
                    { richTextToolbar: true, richTextShortcuts: true , userId:"<%= user.displayName %>" }
                );
                firepad.on('ready', function() {
                    if(firepad.isHistoryEmpty()) {
                        firepad.setHtml('<span style="font-size: 24px;"><%= title %> </span>');
                    }
                });

                var watchLink = $('<li></li>').html('<a href="#" onclick="watchNote()"><span class="glyphicon glyphicon-folder-open"></span>&nbsp;&nbsp;觀看同學筆記</a>');
                $('#navList').append(watchLink);
                var liveLink = $('<li></li>').html('<a href="#" id="joinBroadcast" onclick="livebtn()"><span class="glyphicon glyphicon-globe"></span> 查看課程廣播</a>');
                $('#navList').append(liveLink);
                

                var btn = document.createElement("button");
                btn.setAttribute('onclick',"slidebtn()");
                btn.setAttribute('id',"slidebtn");
                btn.setAttribute('class',"btn navbar-btn btn-info");
                btn.innerHTML = "隱藏筆記";
                var liElement = document.createElement("li");
                liElement.appendChild(btn);
                $('#navList').append(liElement);
                showPPT();
            }

            function showPPT() {
                document.getElementById("video-preview").style.display = "none";
                document.getElementById("slide").style.display = "";
                //$('#ppt').attr('src', url);

            }
            function showVideo(){
                document.getElementById("slide").style.display = "none";
                document.getElementById("slide").style.zIndex = "0";
                document.getElementById("video-preview").style.display = "";
                document.getElementById("video-preview").style.zIndex = "1";
                //$('#learningBlock').append('<video id="video-preview" controls loop></video');
            }
            function slidebtn(){
                var btn = document.getElementById("slidebtn");
                if( btn.innerHTML == "隱藏筆記" ){
                    btn.innerHTML = "顯示筆記";
                    document.getElementById('slide').style.right = "0%";
                    document.getElementById('video-preview').style.width = "100%";
                    document.getElementById('firepad-container').style.left = "100%";
                }
                else if ( btn.innerHTML == "顯示筆記" ){
                    btn.innerHTML = "隱藏筆記";
                    document.getElementById('slide').style.right = "33%";
                    document.getElementById('video-preview').style.width = "67%";
                    document.getElementById('firepad-container').style.left = "67%";
                }
            }
            var pptUrl = parsePPTURL("<%= pptUrl %>");
           
           
            function parsePPTURL(pptUrl){
                var patt = /https:.*?(quot;|#39)/;
                var match = patt.exec(pptUrl);
                var url = match[0].substr(0,match[0].length - 4);
                url = url.replace(/&amp;/g,"&");
                return url;
            }
            function watchNote(){
                var dialog = bootbox.dialog({
                    title: '請輸入同學的Email帳號',
                    message: "<p>例如 : <font color='red'>abc@gmail.com</font> 或 <font color='red'>abc@ncnu.edu.tw</font> 只要輸入 <big><font color='red'>abc</font></big> 即可</p><input id='userEID' type='text' class='form-control'>",
                    buttons: {
                        cancel: {
                            label: "取消",
                            className: 'btn-danger',
                        },
                        ok: {
                            label: "觀看",
                            className: 'btn-info',
                            callback: function(){
                                var userEID = document.getElementById('userEID').value;
                                if(userEID != "" && userEID != undefined){
                                        var firepadRef = firebase.database().ref('/'+'note-'+ userEID).child('<%= title %>');
                                        var codeMirror = CodeMirror(document.getElementById('firepad-container'), { lineWrapping: true });// Actually, you will not modify the content of firepad-container... But it has to do this to use firepad.getHtml()
                                        var shareFirepad = Firepad.fromCodeMirror(firepadRef, codeMirror,
                                            { richTextToolbar: false, richTextShortcuts: true , userId:"<%= user.displayName %>" }
                                        );
                                        shareFirepad.on('ready', function() {
                                            if(shareFirepad.getHtml() == ""){
                                                bootbox.alert('查無此人筆記，請重新輸入');            
                                            }
                                            else{
                                                var alertBox = bootbox.alert(shareFirepad.getHtml());
                                                alertBox.find('.modal-content').css({'user-select': 'none'});
                                            }
                                            shareFirepad.dispose();
                                        });
                                }
                                else{
                                    bootbox.alert('請輸入Email帳號');
                                }
                            }
                        }
                    }
                });


            }       
            function liveSwitchBtn(){
                var switchBtn = document.getElementById("liveSwitchBtn");
                if( switchBtn.innerHTML == "顯示離線的投影片" ){
                    switchBtn.innerHTML = "跟隨線上課程廣播";
                    showPPT(pptUrl);
                }
                else if( switchBtn.innerHTML == "跟隨線上課程廣播" ){
                    switchBtn.innerHTML = "顯示離線的投影片";
                    showVideo();
                }
            }
        </script>
</head>
<body onload="init();">
    <% include layouts/header %>   
    <div class="container-fluid">
        <div class="row">
            <div class="col-sm-6 col-md-6">
                <div class="embed-responsive embed-responsive" id="slide">
                    <iframe id="ppt" allowFullScreen></iframe>
                    <script>
                        $('#ppt').attr('src', pptUrl);
                    </script>
                </div>

                <video id="video-preview" controls loop></video>    

                
                
                <script>
                    // Edit from Open-Sourced: https://github.com/muaz-khan/RTCMultiConnection

                    // --------------------------------------------------
                    // Muaz Khan     - www.MuazKhan.com
                    // MIT License   - www.WebRTC-Experiment.com/licence
                    // --------------------------------------------------


                    // recording is disabled because it is resulting for browser-crash
                    // if you enable below line, please also uncomment above "RecordRTC.js"
                    var enableRecordings = false;

                    var connection = new RTCMultiConnection(null, {
                        useDefaultDevices: true // if we don't need to force selection of specific devices
                    });

                    // its mandatory in v3
                    connection.enableScalableBroadcast = true;

                    // each relaying-user should serve only 1 users
                    connection.maxRelayLimitPerUser = 1;

                    // we don't need to keep room-opened
                    // scalable-broadcast.js will handle stuff itself.
                    connection.autoCloseEntireSession = true;

                    // by default, socket.io server is assumed to be deployed on your own URL
                    connection.socketURL = '/';

                    // comment-out below line if you do not have your own socket.io server
                    // connection.socketURL = 'https://rtcmulticonnection.herokuapp.com:443/';

                    connection.socketMessageEvent = 'note-taking-system';

                    // user need to connect server, so that others can reach him.
                    connection.connectSocket(function(socket) {
                        /*socket.on('logs', function(log) {
                            //console.log(log);
                        });
                        */
                        // this event is emitted when a broadcast is already created.
                        socket.on('join-broadcaster', function(hintsToJoinBroadcast) {
                            console.log('join-broadcaster', hintsToJoinBroadcast);

                            connection.session = hintsToJoinBroadcast.typeOfStreams;
                            connection.sdpConstraints.mandatory = {
                                OfferToReceiveVideo: true,
                                OfferToReceiveAudio: false
                            };
                            connection.join(hintsToJoinBroadcast.userid);
                        });

                        socket.on('rejoin-broadcast', function(broadcastId) {
                            console.log('rejoin-broadcast', broadcastId);

                            connection.attachStreams = [];
                            socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                                if(!isBroadcastExists) {
                                    // the first person (i.e. real-broadcaster) MUST set his user-id
                                    connection.userid = broadcastId;
                                }

                                socket.emit('join-broadcast', {
                                    broadcastId: broadcastId,
                                    userid: connection.userid,
                                    typeOfStreams: connection.session
                                });
                            });
                        });

                        socket.on('broadcast-stopped', function(broadcastId) {
                            bootbox.alert('廣播已結束!');
                            if(document.getElementById('liveSwitchBtn')){ 
                                document.getElementById('liveSwitchBtn').remove();
                            }
                            var pptUrl = parsePPTURL("<%= pptUrl %>");
                            document.getElementById('joinBroadcast').style.pointerEvents = "";
                            showPPT();
                            //location.reload();
                            console.error('broadcast-stopped', broadcastId);
                        });
/*
                        // this event is emitted when a broadcast is absent.
                        socket.on('start-broadcasting', function(typeOfStreams) {
                            console.log('start-broadcasting', typeOfStreams);

                            // host i.e. sender should always use this!
                            connection.sdpConstraints.mandatory = {
                                OfferToReceiveVideo: false,
                                OfferToReceiveAudio: false
                            };
                            connection.session = typeOfStreams;

                            // "open" method here will capture media-stream
                            // we can skip this function always; it is totally optional here.
                            // we can use "connection.getUserMediaHandler" instead
                            connection.open(connection.userid, function() {
                                showRoomURL(connection.sessionid);
                            });
                        });*/
                    });

                    var videoPreview = document.getElementById('video-preview');

                    connection.onstream = function(event) {
                        if(connection.isInitiator && event.type !== 'local') {
                            return;
                        }

                        if(event.mediaElement) {
                            event.mediaElement.pause();
                            delete event.mediaElement;
                        }

                        connection.isUpperUserLeft = false;
                        videoPreview.src = URL.createObjectURL(event.stream);
                        videoPreview.play();

                        videoPreview.userid = event.userid;

                        if(event.type === 'local') {
                            videoPreview.muted = true;
                        }

                        if (connection.isInitiator == false && event.type === 'remote') {
                            // he is merely relaying the media
                            connection.dontCaptureUserMedia = true;
                            connection.attachStreams = [event.stream];
                            connection.sdpConstraints.mandatory = {
                                OfferToReceiveAudio: false,
                                OfferToReceiveVideo: false
                            };

                            var socket = connection.getSocket();
                            socket.emit('can-relay-broadcast');

                            if(connection.DetectRTC.browser.name === 'Chrome') {
                                connection.getAllParticipants().forEach(function(p) {
                                    if(p + '' != event.userid + '') {
                                        var peer = connection.peers[p].peer;
                                        peer.getLocalStreams().forEach(function(localStream) {
                                            peer.removeStream(localStream);
                                        });
                                        peer.addStream(event.stream);
                                        connection.dontAttachStream = true;
                                        connection.renegotiate(p);
                                        connection.dontAttachStream = false;
                                    }
                                });
                            }

                            if(connection.DetectRTC.browser.name === 'Firefox') {
                                // Firefox is NOT supporting removeStream method
                                // that's why using alternative hack.
                                // NOTE: Firefox seems unable to replace-tracks of the remote-media-stream
                                // need to ask all deeper nodes to rejoin
                                connection.getAllParticipants().forEach(function(p) {
                                    if(p + '' != event.userid + '') {
                                        connection.replaceTrack(event.stream, p);
                                    }
                                });
                            }

                            // Firefox seems UN_ABLE to record remote MediaStream
                            // WebAudio solution merely records audio
                            // so recording is skipped for Firefox.
                            if(connection.DetectRTC.browser.name === 'Chrome') {
                                repeatedlyRecordStream(event.stream);
                            }
                        }
                    };     
                    function livebtn(){     
                        var courseRef = firebase.database().ref("/courses").child("<%= courseName %>");
                        courseRef.on("value",function(data){
                            var livePromise = new Promise((resolve, reject) => {
                                resolve(data.val().cid);
                            });
                            livePromise.then(broadcastId => {
                                var socket = connection.getSocket();
                                socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                                    if(!isBroadcastExists) {
                                        // the first person (i.e. real-broadcaster) MUST set his user-id
                                        //connection.userid = broadcastId;
                                        bootbox.alert('<h3>目前老師還沒有在上課喔!</h3>');
                                    }else{
                                        console.log('check-broadcast-presence', broadcastId, isBroadcastExists);

                                        bootbox.confirm({
                                            message: "<h3>目前老師正在上課! <br>是否觀看廣播 ?</h3>",
                                            buttons:{
                                                confirm: {
                                                    label : '觀看',
                                                    className: 'btn-success'
                                                },
                                                cancel : {
                                                    label : '取消',
                                                    className: 'btn-danger'
                                                }
                                            },callback: function(result){
                                                    if(result){  // if click "觀看"
                                                        receiveBroadcast(broadcastId);
                                                    }
                                                }
                                        });
                                            
                                    };                    
                                });
                            }).catch( err => {
                                console.log(err);
                                bootbox.alert('<h3>伺服器忙碌中，請稍後再試一次 ! </h3>');
                            });
                        });
                    };
                    function receiveBroadcast(broadcastId){
                        showVideo();
                        document.getElementById('joinBroadcast').style.pointerEvents = "none";
                        document.getElementById('joinBroadcast').value = broadcastId;
                        var socket = connection.getSocket();
                        connection.session = {
                            screen: true,
                            oneway: true
                        };
                        socket.emit('join-broadcast', {
                            broadcastId: broadcastId,
                            userid: connection.userid,
                            typeOfStreams: connection.session
                        });

                        if(document.getElementById('liveSwitchBtn')){ // 避免出現很多個button
                            document.getElementById('liveSwitchBtn').remove();
                        }
                        var livebtn = document.createElement("button");
                        livebtn.setAttribute('onclick',"liveSwitchBtn()");
                        livebtn.setAttribute('id',"liveSwitchBtn");
                        livebtn.setAttribute('class',"btn btn-danger navbar-btn");
                        livebtn.innerHTML = "顯示離線的投影片";
                        var liElement = document.createElement("li");
                        liElement.appendChild(livebtn);
                        $('#navList').append(liElement);
    
                    }
                                        
                    connection.onstreamended = function() {};

                    connection.onleave = function(event) {
                        if(event.userid !== videoPreview.userid) return;

                        var socket = connection.getSocket();
                        socket.emit('can-not-relay-broadcast');

                        connection.isUpperUserLeft = true;

                        if(allRecordedBlobs.length) {
                            // playing lats recorded blob
                            var lastBlob = allRecordedBlobs[allRecordedBlobs.length - 1];
                            videoPreview.src = URL.createObjectURL(lastBlob);
                            videoPreview.play();
                            allRecordedBlobs = [];
                        }
                        else if(connection.currentRecorder) {
                            var recorder = connection.currentRecorder;
                            connection.currentRecorder = null;
                            recorder.stopRecording(function() {
                                if(!connection.isUpperUserLeft) return;

                                videoPreview.src = URL.createObjectURL(recorder.blob);
                                videoPreview.play();
                            });
                        }

                        if(connection.currentRecorder) {
                            connection.currentRecorder.stopRecording();
                            connection.currentRecorder = null;
                        }
                    };

                    var allRecordedBlobs = [];

                    function repeatedlyRecordStream(stream) {
                        if(!enableRecordings) {
                            return;
                        }

                        connection.currentRecorder = RecordRTC(stream, {
                            type: 'video'
                        });

                        connection.currentRecorder.startRecording();

                        setTimeout(function() {
                            if(connection.isUpperUserLeft || !connection.currentRecorder) {
                                return;
                            }

                            connection.currentRecorder.stopRecording(function() {
                                allRecordedBlobs.push(connection.currentRecorder.blob);

                                if(connection.isUpperUserLeft) {
                                    return;
                                }

                                connection.currentRecorder = null;
                                repeatedlyRecordStream(stream);
                            });
                        }, 30 * 1000); // 30-seconds
                    };

                    // Using getScreenId.js to capture screen from any domain
                    // You do NOT need to deploy Chrome Extension YOUR-Self!!
                    connection.getScreenConstraints = function(callback) {
                        getScreenConstraints(function(error, screen_constraints) {
                            if (!error) {
                                screen_constraints = connection.modifyScreenConstraints(screen_constraints);
                                callback(error, screen_constraints);
                                return;
                            }
                            throw error;
                        });
                    };
        
                </script>
            </div>
            <div class="col-sm-6 col-md-6">
                <div id="firepad-container">
                </div>
            </div>
    </div>
    
</body>
</html>
<!DOCTYPE HTML>
<html>
<head>
        <title>教學筆記系統</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
    
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>   
        <script src="https://www.gstatic.com/firebasejs/4.9.1/firebase.js"></script>
        <!-- Firebase js -->
        <script src="https://www.gstatic.com/firebasejs/4.6.2/firebase.js"></script>    
        <!-- Firepad related js -->  
        <script src="/javascripts/codemirror.js"></script>     
        <script src="/javascripts/firepad.js"></script> 
        <script src="/javascripts/firebase-init.js"></script>
        <!-- Firepad css -->
        <link rel="stylesheet" href="/stylesheets/codemirror.css" />
        <link rel="stylesheet" href="/stylesheets/firepad.css" />
        
        
        <!-- This page css -->
        <link rel="stylesheet" href="/stylesheets/noteWatchPage.css" />
        <link rel="stylesheet" href="/stylesheets/style.css">

        <script src="/javascripts/keywordOverlay.js"></script>
        <script src="/javascripts/bootbox.min.js"></script>

        <!-- Screen Broadcast -->
        <script src="/socket.io/socket.io.js"></script>
        <script src="/javascripts/RTCMultiConnection.min.js"></script>
        <script src="/javascripts/getScreenId.js"></script>

        <script>            
            function init(){  
                initFirebase();
                // Add student from data into select list
                var userRef = firebase.database().ref("users/");
                userRef.on('value',function(data){
                    $('#studentSelect').html("");
                    for(var i in data.val()){
                        if(data.val()[i].character == "student"){
                            var name = data.val()[i].name;
                            var email = data.val()[i].email;
                            var newOption = document.createElement('option');
                            newOption.innerHTML = name + ' < ' + email + ' > ' ;
                            newOption.setAttribute('value',email);
                            $('#studentSelect').append( newOption );
                        }
                    }
                });
                // Add slide link
                var slideLiElement = $('<li></li>').html('<a href="' + parsePPTURL("<%= pptUrl %>") +'" target="#"><span class="glyphicon glyphicon-file"></span> 投影片</a>');
                var liveLiElement = $('<li></li>').html('<a href="#" id="liveBroadcast" onclick="liveBroadcast()"><span class="glyphicon glyphicon-globe"></span> 線上課程廣播</a>');
                $('#navList').append(slideLiElement);
                $('#navList').append(liveLiElement);

                // Select list click
                $('#studentSelect').change(function(){
                    var name = $('#studentSelect').find(':selected').text();
                    var email = $('#studentSelect').find(':selected').val();
                    $('#studentName').text(name);
                    var userEID = email.split('@')[0];
                    choosePad(userEID);
                });

                // Random choose button
                $('#randomStudent').click(function(){
                    var options = $('#studentSelect').find('option');
                    var randomIndex = Math.floor((Math.random() * options.length));
                    var name = options.eq(randomIndex).text();
                    var email = options.eq(randomIndex).val();
                    $('#studentName').text(name);
                    var userEID = email.split('@')[0];
                    choosePad(userEID);
                });
                
            }; 
            // change pad depend on user
            function choosePad(userEID){
                var firepadRef = firebase.database().ref('/'+'note-'+userEID).child('<%= title %>');
                var firepadContainer = document.getElementById('firepad-container');
                firepadContainer.innerHTML = "";
                var codeMirror = CodeMirror(document.getElementById('firepad-container'), { lineWrapping: true });
                hyperlinkOverlay(codeMirror);
                qaOverlay(codeMirror);
                askingOverlay(codeMirror);
                var firepad = Firepad.fromCodeMirror(firepadRef, codeMirror,
                    { richTextToolbar: true, richTextShortcuts: true , userId:"<%= user.displayName %>" }
                );
                $('#showQA').html("");
                $('#showAsking').html("");
                firepad.on('ready', function() {
                    var contentArray = firepad.getText().split("\n");
                    var qaPatt = new RegExp("(^\/Q .*)|(^\/A .*)","i");
                    var qPatt = new RegExp("(^\/Q .*)","i");
                    var aPatt = new RegExp("(^\/A .*)","i");
                    var askingPatt = new RegExp("(^\/[?] .*)","i");
                    for( var i = 0; i < contentArray.length; i++){
                        if( askingPatt.test(contentArray[i]) ){
                            $('#showAsking').append(contentArray[i] + '\n\n');
                        }
                        else if( qaPatt.test(contentArray[i]) ){
                            if (qPatt.test(contentArray[i])){
                                if ( document.getElementById("showQA").innerHTML != "" ){
                                    $('#showQA').append('\n');
                                }
                                $('#showQA').append(contentArray[i] + '\n');
                            }else{
                                $('#showQA').append(contentArray[i] + '\n');
                            } 
                        }
                    }
                });
            }
            function parsePPTURL(pptUrl){
                var patt = /https:.*?(quot;|#39)/;
                var match = patt.exec(pptUrl);
                var url = match[0].substr(0,match[0].length - 4);
                url = url.replace(/&amp;/g,"&");
                return url;
            }
        </script>
</head>
<body onload="init();">
    <% include layouts/header %>
    <div class="container-fluid">
        <div class="row">
            <div class="col-sm-8 col-md-8">
                <div id="firepad-container">
                </div>    
                <textarea class="form-control" id="showQA" readonly></textarea>
                <textarea class="form-control" id="showAsking" readonly></textarea>
            </div>
            <div class="col-sm-4 col-md-4">
                <h3><%= title %></h3>
                <div class="form-group" id="studentBlock">
                    <button id = "randomStudent" type="button" class="btn btn-success">隨機挑選學生</button>
                    <h3>你選擇的是 : <b><div id="studentName">尚未選擇</div> </b></h3>
                    <select class="form-control" id="studentSelect" size="25">
                    </select>
                </div>
            </div>
            <script>
                // recording is disabled because it is resulting for browser-crash
                // if you enable below line, please also uncomment above "RecordRTC.js"
                var enableRecordings = false;

                var connection = new RTCMultiConnection(null, {
                    useDefaultDevices: true // if we don't need to force selection of specific devices
                });

                // its mandatory in v3
                connection.enableScalableBroadcast = true;

                // each relaying-user should serve only 1 users
                connection.maxRelayLimitPerUser = 1;

                // we don't need to keep room-opened
                // scalable-broadcast.js will handle stuff itself.
                connection.autoCloseEntireSession = true;

                // by default, socket.io server is assumed to be deployed on your own URL
                connection.socketURL = '/';

                // comment-out below line if you do not have your own socket.io server
                // connection.socketURL = 'https://rtcmulticonnection.herokuapp.com:443/';

                //connection.socketMessageEvent = 'scalable-screen-broadcast-demo';
                connection.socketMessageEvent = 'note-taking_system';

                // user need to connect server, so that others can reach him.
                connection.connectSocket(function(socket) {
                    socket.on('logs', function(log) {
                    //    document.querySelector('h1').innerHTML = log.replace(/</g, '----').replace(/>/g, '___').replace(/----/g, '(<span style="color:red;">').replace(/___/g, '</span>)');
                        console.log(log);
                    });
                    
                    // this event is emitted when a broadcast is already created.
                    socket.on('join-broadcaster', function(hintsToJoinBroadcast) {
                        console.log('join-broadcaster', hintsToJoinBroadcast);

                        connection.session = hintsToJoinBroadcast.typeOfStreams;
                        connection.sdpConstraints.mandatory = {
                            OfferToReceiveVideo: true,
                            OfferToReceiveAudio: false
                        };
                        connection.join(hintsToJoinBroadcast.userid);
                    });

                    socket.on('rejoin-broadcast', function(broadcastId) {
                        console.log('rejoin-broadcast', broadcastId);

                        connection.attachStreams = [];
                        socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                            if(!isBroadcastExists) {
                                // the first person (i.e. real-broadcaster) MUST set his user-id
                                connection.userid = broadcastId;
                            }

                            socket.emit('join-broadcast', {
                                broadcastId: broadcastId,
                                userid: connection.userid,
                                typeOfStreams: connection.session
                            });
                        });
                    });
/*
                    socket.on('broadcast-stopped', function(broadcastId) {
                        // alert('Broadcast has been stopped.');
                        // location.reload();
                        console.error('broadcast-stopped', broadcastId);
                        alert('This broadcast has been stopped.');
                    });
*/
                    // this event is emitted when a broadcast is absent.
                    socket.on('start-broadcasting', function(typeOfStreams) {
                        console.log('start-broadcasting', typeOfStreams);

                        // host i.e. sender should always use this!
                        connection.sdpConstraints.mandatory = {
                            OfferToReceiveVideo: false,
                            OfferToReceiveAudio: false
                        };
                        connection.session = typeOfStreams;

                        // "open" method here will capture media-stream
                        // we can skip this function always; it is totally optional here.
                        // we can use "connection.getUserMediaHandler" instead
                        connection.open(connection.userid, function() {
                            //showRoomURL(connection.sessionid);
                        });
                    });
                });
/*
                window.onbeforeunload = function() {
                    // Firefox is ugly.
                    document.getElementById('open-or-join').disabled = false;
                };
*/
                //var videoPreview = document.getElementById('video-preview');

                connection.onstream = function(event) {
                    if(connection.isInitiator && event.type !== 'local') {
                        return;
                    }

                    if(event.mediaElement) {
                        event.mediaElement.pause();
                        delete event.mediaElement;
                    }

                    connection.isUpperUserLeft = false;
                    //videoPreview.src = URL.createObjectURL(event.stream);
                    //videoPreview.play();

                    //videoPreview.userid = event.userid;
                    /*
                    if(event.type === 'local') {
                        videoPreview.muted = true;
                    }
                    */
                    if (connection.isInitiator == false && event.type === 'remote') {
                        // he is merely relaying the media
                        connection.dontCaptureUserMedia = true;
                        connection.attachStreams = [event.stream];
                        connection.sdpConstraints.mandatory = {
                            OfferToReceiveAudio: false,
                            OfferToReceiveVideo: false
                        };

                        var socket = connection.getSocket();
                        socket.emit('can-relay-broadcast');

                        if(connection.DetectRTC.browser.name === 'Chrome') {
                            connection.getAllParticipants().forEach(function(p) {
                                if(p + '' != event.userid + '') {
                                    var peer = connection.peers[p].peer;
                                    peer.getLocalStreams().forEach(function(localStream) {
                                        peer.removeStream(localStream);
                                    });
                                    peer.addStream(event.stream);
                                    connection.dontAttachStream = true;
                                    connection.renegotiate(p);
                                    connection.dontAttachStream = false;
                                }
                            });
                        }

                        if(connection.DetectRTC.browser.name === 'Firefox') {
                            // Firefox is NOT supporting removeStream method
                            // that's why using alternative hack.
                            // NOTE: Firefox seems unable to replace-tracks of the remote-media-stream
                            // need to ask all deeper nodes to rejoin
                            connection.getAllParticipants().forEach(function(p) {
                                if(p + '' != event.userid + '') {
                                    connection.replaceTrack(event.stream, p);
                                }
                            });
                        }

                        // Firefox seems UN_ABLE to record remote MediaStream
                        // WebAudio solution merely records audio
                        // so recording is skipped for Firefox.
                        if(connection.DetectRTC.browser.name === 'Chrome') {
                            repeatedlyRecordStream(event.stream);
                        }
                    }
                };

                // ask node.js server to look for a broadcast
                // if broadcast is available, simply join it. i.e. "join-broadcaster" event should be emitted.
                // if broadcast is absent, simply create it. i.e. "start-broadcasting" event should be fired.
                //document.getElementById('open-or-join').onclick = function() {
                function liveBroadcast(){
                    var promiseResult = new Promise(function(resolve,reject){
                    // get the live code according to the chapter title 
                    var courseRef = firebase.database().ref("courses/" + "<%= courseName %>");
                        courseRef.on("value",function(data){
                            resolve(data.val().cid);
                        });     
                    });
                    promiseResult.then(broadcastId => {
                         connection.session = {
                            screen: true,
                            oneway: true
                        };
                        var socket = connection.getSocket();

                        socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                            if(!isBroadcastExists) {
                                // the first person (i.e. real-broadcaster) MUST set his user-id
                                connection.userid = broadcastId;
                            }
                            console.log('check-broadcast-presence', broadcastId, isBroadcastExists);

                            socket.emit('join-broadcast', {
                                broadcastId: broadcastId,
                                userid: connection.userid,
                                typeOfStreams: connection.session
                            });
                         });                                            
                    });
                }

                connection.onstreamended = function() {};
/*
                connection.onleave = function(event) {
                    if(event.userid !== videoPreview.userid) return;

                    var socket = connection.getSocket();
                    socket.emit('can-not-relay-broadcast');

                    connection.isUpperUserLeft = true;

                    if(allRecordedBlobs.length) {
                        // playing lats recorded blob
                        var lastBlob = allRecordedBlobs[allRecordedBlobs.length - 1];
                        videoPreview.src = URL.createObjectURL(lastBlob);
                        videoPreview.play();
                        allRecordedBlobs = [];
                    }
                    else if(connection.currentRecorder) {
                        var recorder = connection.currentRecorder;
                        connection.currentRecorder = null;
                        recorder.stopRecording(function() {
                            if(!connection.isUpperUserLeft) return;

                            videoPreview.src = URL.createObjectURL(recorder.blob);
                            videoPreview.play();
                        });
                    }

                    if(connection.currentRecorder) {
                        connection.currentRecorder.stopRecording();
                        connection.currentRecorder = null;
                    }
                };
*/
                var allRecordedBlobs = [];

                function repeatedlyRecordStream(stream) {
                    if(!enableRecordings) {
                        return;
                    }

                    connection.currentRecorder = RecordRTC(stream, {
                        type: 'video'
                    });

                    connection.currentRecorder.startRecording();

                    setTimeout(function() {
                        if(connection.isUpperUserLeft || !connection.currentRecorder) {
                            return;
                        }

                        connection.currentRecorder.stopRecording(function() {
                            allRecordedBlobs.push(connection.currentRecorder.blob);

                            if(connection.isUpperUserLeft) {
                                return;
                            }

                            connection.currentRecorder = null;
                            repeatedlyRecordStream(stream);
                        });
                    }, 30 * 1000); // 30-seconds
                };

                // Using getScreenId.js to capture screen from any domain
                // You do NOT need to deploy Chrome Extension YOUR-Self!!
                connection.getScreenConstraints = function(callback) {
                    getScreenConstraints(function(error, screen_constraints) {
                        if (!error) {
                            screen_constraints = connection.modifyScreenConstraints(screen_constraints);
                            callback(error, screen_constraints);
                            return;
                        }
                        throw error;
                    });
                };
/*
                function disableInputButtons() {
                    document.getElementById('open-or-join').disabled = true;
                    document.getElementById('broadcast-id').disabled = true;
                }

                // ......................................................
                // ......................Handling broadcast-id................
                // ......................................................

                function showRoomURL(broadcastId) {
                    var roomHashURL = '#' + broadcastId;
                    var roomQueryStringURL = '?broadcastId=' + broadcastId;

                    var html = '<h2>Unique URL for your room:</h2><br>';

                    html += 'Hash URL: <a href="' + roomHashURL + '" target="_blank">' + roomHashURL + '</a>';
                    html += '<br>';
                    html += 'QueryString URL: <a href="' + roomQueryStringURL + '" target="_blank">' + roomQueryStringURL + '</a>';

                    var roomURLsDiv = document.getElementById('room-urls');
                    roomURLsDiv.innerHTML = html;

                    roomURLsDiv.style.display = 'block';
                }

                (function() {
                    var params = {},
                        r = /([^&=]+)=?([^&]*)/g;

                    function d(s) {
                        return decodeURIComponent(s.replace(/\+/g, ' '));
                    }
                    var match, search = window.location.search;
                    while (match = r.exec(search.substring(1)))
                        params[d(match[1])] = d(match[2]);
                    window.params = params;
                })();

                var broadcastId = '';
                if (localStorage.getItem(connection.socketMessageEvent)) {
                    broadcastId = localStorage.getItem(connection.socketMessageEvent);
                } else {
                    broadcastId = connection.token();
                }
                document.getElementById('broadcast-id').value = broadcastId;
                document.getElementById('broadcast-id').onkeyup = function() {
                    localStorage.setItem(connection.socketMessageEvent, this.value);
                };

                var hashString = location.hash.replace('#', '');
                if(hashString.length && hashString.indexOf('comment-') == 0) {
                hashString = '';
                }

                var broadcastId = params.broadcastId;
                if(!broadcastId && hashString.length) {
                    broadcastId = hashString;
                }

                if(broadcastId && broadcastId.length) {
                    //document.getElementById('broadcast-id').value = broadcastId;
                    localStorage.setItem(connection.socketMessageEvent, broadcastId);

                    // auto-join-room
                    (function reCheckRoomPresence() {
                        connection.checkPresence(broadcastId, function(isRoomExists) {
                            if(isRoomExists) {
                                document.getElementById('liveBroadcast').onclick();
                                return;
                            }

                            setTimeout(reCheckRoomPresence, 5000);
                        });
                    })();

                    //disableInputButtons();
                }
*/

            </script>
    </div>
</body>
</html>
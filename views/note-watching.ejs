<!DOCTYPE HTML>
<html>
<head>
        <title>教學筆記系統</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
    
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>   
        <script src="https://www.gstatic.com/firebasejs/4.9.1/firebase.js"></script>
        <!-- Firebase js -->
        <script src="https://www.gstatic.com/firebasejs/4.6.2/firebase.js"></script>    
        <!-- Firepad related js -->  
        <script src="/javascripts/codemirror.js"></script>     
        <script src="/javascripts/firepad.js"></script> 
        <script src="/javascripts/firebase-init.js"></script>
        <!-- Firepad css -->
        <link rel="stylesheet" href="/stylesheets/codemirror.css" />
        <link rel="stylesheet" href="/stylesheets/firepad.css" />
        
        
        <!-- This page css -->
        <link rel="stylesheet" href="/stylesheets/noteWatchPage.css" />
        <link rel="stylesheet" href="/stylesheets/style.css">

        <script src="/javascripts/keywordOverlay.js"></script>
        <script src="/javascripts/bootbox.min.js"></script>

        <!-- Screen Broadcast -->
        <script src="/socket.io/socket.io.js"></script>
        <script src="/javascripts/RTCMultiConnection.min.js"></script>
        <script src="/javascripts/getScreenId.js"></script>
        <script>
 
        </script>


        <script>            
            function init(){  
                initFirebase();

                // Add slide link
                var slideLiElement = $('<li></li>').html('<a href="' + parsePPTURL("<%= pptUrl %>") +'" target="#"><span class="glyphicon glyphicon-file"></span> 投影片</a>');
                var liveLiElement = $('<li></li>').html('<a href="#" id="liveBroadcast" onclick="liveBroadcast()"><span class="glyphicon glyphicon-globe"></span> 線上課程廣播</a>');
                $('#navList').append(slideLiElement);
                $('#navList').append(liveLiElement);
                
                
                // Add student from data into select list
                var userRef = firebase.database().ref("users/");
                userRef.on('value',function(data){
                    $('#studentSelect').html("");
                    for(var i in data.val()){
                        if(data.val()[i].character == "student"){
                            var name = data.val()[i].name;
                            var email = data.val()[i].email;
                            var newOption = document.createElement('option');
                            newOption.innerHTML = name + ' < ' + email + ' > ' ;
                            newOption.setAttribute('value',email);
                            $('#studentSelect').append( newOption );
                        }
                    }
                });

                // Select list click
                $('#studentSelect').change(function(){
                    var name = $('#studentSelect').find(':selected').text();
                    var email = $('#studentSelect').find(':selected').val();
                    $('#studentName').text(name);
                    var userEID = email.split('@')[0];
                    choosePad(userEID);
                });

                // Random choose button
                $('#randomStudent').click(function(){
                    var options = $('#studentSelect').find('option');
                    var randomIndex = Math.floor((Math.random() * options.length));
                    var name = options.eq(randomIndex).text();
                    var email = options.eq(randomIndex).val();
                    $('#studentName').text(name);
                    var userEID = email.split('@')[0];
                    choosePad(userEID);
                });
                
            }; 
            // change pad depend on user
            function choosePad(userEID){
                var firepadRef = firebase.database().ref('/'+'note-'+userEID).child('<%= title %>');
                var firepadContainer = document.getElementById('firepad-container');
                firepadContainer.innerHTML = "";
                var codeMirror = CodeMirror(document.getElementById('firepad-container'), { lineWrapping: true });
                hyperlinkOverlay(codeMirror);
                qaOverlay(codeMirror);
                askingOverlay(codeMirror);
                var firepad = Firepad.fromCodeMirror(firepadRef, codeMirror,
                    { richTextToolbar: true, richTextShortcuts: true , userId:"<%= user.displayName %>" }
                );
                $('#showQA').html("");
                $('#showAsking').html("");
                firepad.on('ready', function() {
                    var contentArray = firepad.getText().split("\n");
                    var qaPatt = new RegExp("(^\/Q .*)|(^\/A .*)","i");
                    var qPatt = new RegExp("(^\/Q .*)","i");
                    var aPatt = new RegExp("(^\/A .*)","i");
                    var askingPatt = new RegExp("(^\/[?] .*)","i");
                    for( var i = 0; i < contentArray.length; i++){
                        if( askingPatt.test(contentArray[i]) ){
                            $('#showAsking').append(contentArray[i] + '\n\n');
                        }
                        else if( qaPatt.test(contentArray[i]) ){
                            if (qPatt.test(contentArray[i])){
                                if ( document.getElementById("showQA").innerHTML != "" ){
                                    $('#showQA').append('\n');
                                }
                                $('#showQA').append(contentArray[i] + '\n');
                            }else{
                                $('#showQA').append(contentArray[i] + '\n');
                            } 
                        }
                    }
                });
            }
            function parsePPTURL(pptUrl){
                var patt = /https:.*?(quot;|#39)/;
                var match = patt.exec(pptUrl);
                var url = match[0].substr(0,match[0].length - 4);
                url = url.replace(/&amp;/g,"&");
                return url;
            }
        </script>
</head>
<body onload="init();">
    <% include layouts/header %>
    <div class="container-fluid">
        <div class="row">
            <div class="col-sm-8 col-md-8">
                <div id="firepad-container">
                </div>    
                <textarea class="form-control" id="showQA" readonly></textarea>
                <textarea class="form-control" id="showAsking" readonly></textarea>
            </div>
            <div class="col-sm-4 col-md-4">
                <br><br>
                <h3 align="center"><strong><%= title %></strong></h3>
                <hr>
                <div class="form-group" id="studentBlock">
                    <button id = "randomStudent" type="button" class="btn btn-success">隨機挑選學生</button>
                    <h3>你選擇的是 : <b><div id="studentName">尚未選擇</div> </b></h3>
                    <select class="form-control" id="studentSelect" size="25">
                    </select>
                </div>
            </div>
            <script>
                // Edit from Open-Sourced: https://github.com/muaz-khan/RTCMultiConnection

                // --------------------------------------------------
                // Muaz Khan     - www.MuazKhan.com
                // MIT License   - www.WebRTC-Experiment.com/licence
                // --------------------------------------------------


                // recording is disabled because it is resulting for browser-crash
                // if you enable below line, please also uncomment above "RecordRTC.js"
                var enableRecordings = false;

                var connection = new RTCMultiConnection(null, {
                    useDefaultDevices: true // if we don't need to force selection of specific devices
                });

                // its mandatory in v3
                connection.enableScalableBroadcast = true;

                // each relaying-user should serve only 1 users
                connection.maxRelayLimitPerUser = 1;

                // we don't need to keep room-opened
                // scalable-broadcast.js will handle stuff itself.
                connection.autoCloseEntireSession = true;

                // by default, socket.io server is assumed to be deployed on your own URL
                connection.socketURL = '/';

                // comment-out below line if you do not have your own socket.io server
                // connection.socketURL = 'https://rtcmulticonnection.herokuapp.com:443/';

                connection.socketMessageEvent = 'note-taking-system';

                // user need to connect server, so that others can reach him.
                connection.connectSocket(function(socket) {
                    socket.on('logs', function(log) {
                    //    document.querySelector('h1').innerHTML = log.replace(/</g, '----').replace(/>/g, '___').replace(/----/g, '(<span style="color:red;">').replace(/___/g, '</span>)');
                        console.log(log);
                    });
                    
                    // this event is emitted when a broadcast is already created.
                    socket.on('join-broadcaster', function(hintsToJoinBroadcast) {
                        console.log('join-broadcaster', hintsToJoinBroadcast);

                        connection.session = hintsToJoinBroadcast.typeOfStreams;
                        connection.sdpConstraints.mandatory = {
                            OfferToReceiveVideo: true,
                            OfferToReceiveAudio: false
                        };
                        connection.join(hintsToJoinBroadcast.userid);
                    });

                    socket.on('rejoin-broadcast', function(broadcastId) {
                        console.log('rejoin-broadcast', broadcastId);

                        connection.attachStreams = [];
                        socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                            if(!isBroadcastExists) {
                                // the first person (i.e. real-broadcaster) MUST set his user-id
                                connection.userid = broadcastId;
                            }

                            socket.emit('join-broadcast', {
                                broadcastId: broadcastId,
                                userid: connection.userid,
                                typeOfStreams: connection.session
                            });
                        });
                    });

                    // this event is emitted when a broadcast is absent.
                    socket.on('start-broadcasting', function(typeOfStreams) {
                        console.log('start-broadcasting', typeOfStreams);

                        // host i.e. sender should always use this!
                        connection.sdpConstraints.mandatory = {
                            OfferToReceiveVideo: false,
                            OfferToReceiveAudio: false
                        };
                        connection.session = typeOfStreams;

                        // "open" method here will capture media-stream
                        // we can skip this function always; it is totally optional here.
                        // we can use "connection.getUserMediaHandler" instead
                        connection.open(connection.userid, function() {
                            //showRoomURL(connection.sessionid);
                        });
                    });
                });

                connection.onstream = function(event) {
                    if(connection.isInitiator && event.type !== 'local') {
                        return;
                    }

                    if(event.mediaElement) {
                        event.mediaElement.pause();
                        delete event.mediaElement;
                    }

                    connection.isUpperUserLeft = false;

                    if (connection.isInitiator == false && event.type === 'remote') {
                        // he is merely relaying the media
                        connection.dontCaptureUserMedia = true;
                        connection.attachStreams = [event.stream];
                        connection.sdpConstraints.mandatory = {
                            OfferToReceiveAudio: false,
                            OfferToReceiveVideo: false
                        };

                        var socket = connection.getSocket();
                        socket.emit('can-relay-broadcast');

                        if(connection.DetectRTC.browser.name === 'Chrome') {
                            connection.getAllParticipants().forEach(function(p) {
                                if(p + '' != event.userid + '') {
                                    var peer = connection.peers[p].peer;
                                    peer.getLocalStreams().forEach(function(localStream) {
                                        peer.removeStream(localStream);
                                    });
                                    peer.addStream(event.stream);
                                    connection.dontAttachStream = true;
                                    connection.renegotiate(p);
                                    connection.dontAttachStream = false;
                                }
                            });
                        }

                        if(connection.DetectRTC.browser.name === 'Firefox') {
                            // Firefox is NOT supporting removeStream method
                            // that's why using alternative hack.
                            // NOTE: Firefox seems unable to replace-tracks of the remote-media-stream
                            // need to ask all deeper nodes to rejoin
                            connection.getAllParticipants().forEach(function(p) {
                                if(p + '' != event.userid + '') {
                                    connection.replaceTrack(event.stream, p);
                                }
                            });
                        }

                        // Firefox seems UN_ABLE to record remote MediaStream
                        // WebAudio solution merely records audio
                        // so recording is skipped for Firefox.
                        if(connection.DetectRTC.browser.name === 'Chrome') {
                            repeatedlyRecordStream(event.stream);
                        }
                    }
                };
                // Detect capture screen extension and browser
                // Only Chrome can broadcast screen. (Because Screen Capturing is only in Chrome...)
                function liveBroadcast(){
                    var isChrome = !!window.chrome && !!window.chrome.webstore;
                    if(isChrome){
                        getChromeExtensionStatus(function(status) {
                            if (status === 'installed-enabled'){ 
                                var dialog = bootbox.dialog({
                                    title : "<h2 align='center'>系統提醒</h2>",
                                    message : "<h3>您已安裝並啟用 Screen Capturing，可以擷取螢幕並廣播給學生囉 ! </h3>",
                                    buttons: {
                                        calcel : {
                                            label : "稍後再廣播",
                                            className : "btn-danger"
                                        },
                                        ok : {
                                            label : "開始廣播 ! ",
                                            className : "btn-success",
                                            callback : function() {
                                                startBroadcasting();
                                            }
                                        }
                                    }
                                });
                                
                            } 
                            else if (status === 'installed-disabled'){
                                var dialog = bootbox.dialog({
                                    title : "<h2 align='center'>系統提醒</h2>",
                                    message : "<h3>您已安裝 Screen Capturing，若要使用<font color='red'> 線上課程廣播 </font>，請到 <a target='chromeExtension' href='chrome://extensions/'>擴充功能</a> 啟用 </h3>",
                                    buttons: {
                                        cancel : {
                                            label : "我知道了，先不啟用",
                                            className : "btn-danger"
                                        },
                                        ok : {
                                            label : "點我立即啟用" ,
                                            className : "btn-success",
                                            callback : function(){
                                                var enableSC = document.createElement('a');
                                                enableSC.setAttribute('href', 'chrome://extensions/');
                                                enableSC.setAttribute('target', 'chromeExtension');
                                                enableSC.click();
                                            }
                                        }
                                    }
                                });
                            }else if(status === 'not-installed'){
                                var dialog = bootbox.dialog({
                                    title : "<h2 align='center'>系統提醒</h2>",
                                    message : "<h3>您的 Google Chrome 尚未安裝 Screen Capturing，若要使用<font color='red'> 線上課程廣播 </font>功能來擷取螢幕並廣播，請先安裝 <a target='screenCapturing' href='https://chrome.google.com/webstore/detail/screen-capturing/ajhifddimkapgcifgcodmmfdlknahffk'>Screen Capturing 套件 </a>，並到 擴充功能(chrome://extensions/) 啟用 </h3> <br> <h4>註 : 請勿使用無痕模式</h4>",
                                    buttons: {
                                        cancel : {
                                            label : "我知道了，先不安裝",
                                            className : "btn-danger"
                                        },
                                        ok : {
                                            label : "點我立即安裝" ,
                                            className : "btn-success",
                                            callback : function(){
                                                var installSC = document.createElement('a');
                                                installSC.setAttribute('href', 'https://chrome.google.com/webstore/detail/screen-capturing/ajhifddimkapgcifgcodmmfdlknahffk');
                                                installSC.setAttribute('target', 'screenCapturing');
                                                installSC.click();
                                            }
                                        }
                                    }
                                });
                            }
                            return status;
                        });
                    }else{  // Not use chrome 
                    var dialog = bootbox.dialog({
                                    title : "<h2 align='center'>系統提醒</h2>",
                                    message : "<h3>若要使用<font color='red'> 線上課程廣播 </font>功能來擷取螢幕並廣播，請使用 <font color='red'>Google Chrome</font> 並安裝 <a target='screenCapturing' href='https://chrome.google.com/webstore/detail/screen-capturing/ajhifddimkapgcifgcodmmfdlknahffk'>Screen Capturing 套件 </a> </h3>",
                                    buttons: {
                                        cancel : {
                                            label : "我知道了，先不使用廣播功能",
                                            className : "btn-danger"
                                        }
                                    }       
                                });
                        return 'not-chrome';
                    }
                    
                }

                // ask node.js server to look for a broadcast
                // if broadcast is available, simply join it. i.e. "join-broadcaster" event should be emitted.
                // if broadcast is absent, simply create it. i.e. "start-broadcasting" event should be fired.
                //document.getElementById('open-or-join').onclick = function() {
                function startBroadcasting(){
                    var promiseResult = new Promise(function(resolve,reject){
                    // Use the cid as the broadcastId, so that each course has its own broadcast stream.
                    var courseRef = firebase.database().ref("courses/" + "<%= courseName %>");
                        courseRef.on("value",function(data){
                            resolve(data.val().cid);
                        });     
                    });
                    promiseResult.then(broadcastId => {
                         connection.session = {
                            screen: true,
                            oneway: true
                        };
                        var socket = connection.getSocket();

                        socket.emit('check-broadcast-presence', broadcastId, function(isBroadcastExists) {
                            if(!isBroadcastExists) {
                                // the first person (i.e. real-broadcaster) MUST set his user-id
                                connection.userid = broadcastId;
                            }
                            console.log('check-broadcast-presence', broadcastId, isBroadcastExists);

                            socket.emit('join-broadcast', {
                                broadcastId: broadcastId,
                                userid: connection.userid,
                                typeOfStreams: connection.session
                            });
                         });                                            
                    });
                }

                connection.onstreamended = function() {
                    //location.reload(); 
                    console.log("stream end");
                };
                var allRecordedBlobs = [];

                function repeatedlyRecordStream(stream) {
                    if(!enableRecordings) {
                        return;
                    }

                    connection.currentRecorder = RecordRTC(stream, {
                        type: 'video'
                    });

                    connection.currentRecorder.startRecording();

                    setTimeout(function() {
                        if(connection.isUpperUserLeft || !connection.currentRecorder) {
                            return;
                        }

                        connection.currentRecorder.stopRecording(function() {
                            allRecordedBlobs.push(connection.currentRecorder.blob);

                            if(connection.isUpperUserLeft) {
                                return;
                            }

                            connection.currentRecorder = null;
                            repeatedlyRecordStream(stream);
                        });
                    }, 30 * 1000); // 30-seconds
                };

                // Using getScreenId.js to capture screen from any domain
                // You do NOT need to deploy Chrome Extension YOUR-Self!!
                connection.getScreenConstraints = function(callback) {
                    getScreenConstraints(function(error, screen_constraints) {
                        if (!error) {
                            screen_constraints = connection.modifyScreenConstraints(screen_constraints);
                            callback(error, screen_constraints);
                            return;
                        }
                        throw error;
                    });
                };
            </script>
    </div>
</body>
</html>